/**
 * Algorithm Execution Component
 * Executes algorithms retrieved from database or generated by OpenAI
 */

import { 
  ComponentImplementation, 
  ComponentExecutionContext,
  ComponentExecutionResult
} from '../types.ts';
import { v4 as uuidv4 } from 'uuid';
import { VM } from 'vm2';

/**
 * Algorithm Execution Component
 * Executes algorithms with provided data
 */
export const algorithmExecutionComponent: ComponentImplementation = async (
  context: ComponentExecutionContext
): Promise<ComponentExecutionResult> => {
  try {
    const { inputData, memoryIntegration } = context;
    const { 
      algorithm, 
      data, 
      parameters,
      executionOptions
    } = inputData;
    
    if (!algorithm || !algorithm.code) {
      return {
        success: false,
        errorMessage: 'No valid algorithm provided for execution',
        outputData: null
      };
    }
    
    // Start execution timer
    const startTime = new Date();
    
    // Execute the algorithm
    const results = await executeAlgorithm(
      algorithm.code,
      data,
      parameters || algorithm.parameters,
      executionOptions
    );
    
    // End execution timer
    const endTime = new Date();
    const executionTimeMs = endTime.getTime() - startTime.getTime();
    
    // Create execution metadata
    const executionMetadata = {
      algorithmId: algorithm.id,
      algorithmName: algorithm.name,
      algorithmType: algorithm.type,
      executionId: uuidv4(),
      startTime: startTime.toISOString(),
      endTime: endTime.toISOString(),
      executionTimeMs,
      success: true
    };
    
    // Store execution results in working memory
    const memoryKey = `algorithm:execution:${executionMetadata.executionId}`;
    await memoryIntegration.storeInWorkingMemory(memoryKey, {
      algorithm: {
        id: algorithm.id,
        name: algorithm.name,
        type: algorithm.type
      },
      data,
      parameters,
      results,
      metadata: executionMetadata
    });
    
    // Store in short-term memory for potential reuse
    await memoryIntegration.storeInShortTermMemory(
      memoryKey,
      {
        algorithm: {
          id: algorithm.id,
          name: algorithm.name,
          type: algorithm.type
        },
        results,
        metadata: executionMetadata
      },
      ['algorithm_execution', algorithm.type, algorithm.name]
    );
    
    // For successful executions, store in long-term memory for learning
    await memoryIntegration.storeComponentExecution(
      algorithm.id,
      data,
      results,
      true
    );
    
    return {
      success: true,
      outputData: {
        results,
        metadata: executionMetadata
      }
    };
  } catch (error) {
    console.error('Error in algorithm execution component:', error);
    
    // Create error metadata
    const errorMetadata = {
      algorithmId: inputData.algorithm?.id,
      algorithmName: inputData.algorithm?.name,
      algorithmType: inputData.algorithm?.type,
      executionId: uuidv4(),
      startTime: new Date().toISOString(),
      endTime: new Date().toISOString(),
      success: false,
      error: error.message
    };
    
    // Store error in memory for learning
    if (inputData.algorithm?.id) {
      await context.memoryIntegration.storeComponentExecution(
        inputData.algorithm.id,
        inputData.data,
        null,
        false
      );
    }
    
    return {
      success: false,
      errorMessage: error.message || 'Algorithm execution failed',
      outputData: {
        metadata: errorMetadata
      }
    };
  }
};

/**
 * Executes an algorithm with provided data and parameters
 */
async function executeAlgorithm(
  code: string,
  data: any,
  parameters: any,
  options?: any
): Promise<any> {
  try {
    // Set execution timeout
    const timeout = options?.timeoutMs || 5000;
    
    // Create a sandbox for secure execution
    const vm = new VM({
      timeout,
      sandbox: {
        console: {
          log: (...args: any[]) => {
            if (options?.debug) {
              console.log('[Algorithm Debug]', ...args);
            }
          },
          error: (...args: any[]) => {
            if (options?.debug) {
              console.error('[Algorithm Error]', ...args);
            }
          }
        }
      }
    });
    
    // Prepare the algorithm code for execution
    const wrappedCode = `
      ${code}
      
      // Extract the exported function
      const algorithmFunction = (typeof module.exports === 'function') 
        ? module.exports 
        : (typeof module.exports === 'object' && module.exports.default) 
          ? module.exports.default 
          : null;
      
      if (!algorithmFunction) {
        throw new Error('Algorithm does not export a valid function');
      }
      
      // Execute the algorithm
      const results = algorithmFunction(${JSON.stringify(data)}, ${JSON.stringify(parameters)});
      results;
    `;
    
    // Execute the algorithm in the sandbox
    const results = vm.run(wrappedCode);
    
    return results;
  } catch (error) {
    if (error.message.includes('Script execution timed out')) {
      throw new Error(`Algorithm execution timed out after ${options?.timeoutMs || 5000}ms`);
    }
    throw error;
  }
}

/**
 * Register algorithm execution component
 */
export function registerAlgorithmExecutionComponent(componentRegistry: any): void {
  componentRegistry.registerImplementation('algorithm-execution', algorithmExecutionComponent);
}
